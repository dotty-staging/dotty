package dotty.tools.dotc.typer

import dotty.tools.dotc.ast.*, untpd.*
import dotty.tools.dotc.core.Contexts.*
import dotty.tools.dotc.core.Flags.*
import dotty.tools.dotc.core.Names.*
import dotty.tools.dotc.core.Scopes.*
import dotty.tools.dotc.core.StdNames.*
import dotty.tools.dotc.core.Symbols.*

/** Creation of top-level extension modules */
object TopLevelExtensionModules:
  import tpd.*

  /** Creates the symbols for a new extension module associated with the current
   *  top-level class. These definitions are invisible in the source code.
   *
   * ```scala
   *  class C
   *  // symbols generated by `newAccessorModule("$extension")`
   *  lazy val C$extension = new C$extension$
   *  class C$extension$
   *  ```
   *
   *  @param suffix suffix that will be appended to the name of the top-level class
   *  @return The class symbol of the new module
   */
  def newAccessorModule(suffix: String)(using Context): ClassSymbol =
    val inlineAccessorObjectName: TermName =
      assert(suffix.startsWith("$"), "suffix should start with $")
      assert(suffix.size > 1, "suffix should start with $ followed by a name")
      val fileName = ctx.source.file.name
      val sourceName = ctx.owner.topLevelClass.name
      (sourceName ++ suffix).toTermName

    val mod = newNormalizedModuleSymbol(
      ctx.owner.topLevelClass.owner,
      inlineAccessorObjectName,
      ModuleValCreationFlags & Invisible,
      ModuleClassCreationFlags & Invisible,
      List(defn.ObjectClass.typeRef),
      newScope,
      NoSymbol,
      coord = ctx.owner.topLevelClass.span
    )
    val cls = mod.moduleClass.asClass
    cls.enter(newConstructor(cls, Synthetic, Nil, Nil))
    cls

  /** Generate a list with the ValDef and TypeDef trees of an extension module (created with `newAccessorModule`).
   *
   * ```scala
   *  // given the moduleClassSym for `C$extension$` and `body` this generates the trees
   *  lazy val C$extension = new C$extension$
   *  class C$extension$:
   *    <body*>
   *  ```
   *  @param moduleClassSym class symbol of the extension module
   *  @param body list of definitions in the extension module
   */
  def topLevelModuleDefTree(moduleClassSym: ClassSymbol, body: List[Tree])(using Context): List[Tree] =
    assert(moduleClassSym.owner.is(Package))
    val untpdCtr = untpd.DefDef(nme.CONSTRUCTOR, Nil, tpd.TypeTree(defn.UnitClass.typeRef), tpd.EmptyTree)
    val ctr = ctx.typeAssigner.assignType(untpdCtr, moduleClassSym.primaryConstructor)

    val parents = List(TypeTree(defn.ObjectClass.typeRef))
    val clsDef =
      tpd.ClassDefWithParents(moduleClassSym.asClass, ctr, parents, body)
        .withSpan(moduleClassSym.span)

    val newCls =
      Apply(New(ref(moduleClassSym)).select(moduleClassSym.primaryConstructor), Nil)
    val modVal =
      ValDef(moduleClassSym.companionModule.asTerm, newCls).withSpan(clsDef.span)
        .withSpan(moduleClassSym.companionModule.span)
    List(modVal, clsDef)
